#!/usr/bin/python3
"""
    usm <command> ...

Commands:
    help
        Show this help page.
    init
        Initializes a fresh USM repository (you shouldn't need to use this)
    copy-script
        Copies the latest version of the USM startup script to ~/.usm-env.
        (You shouldn't need to use this either).
    add SOFTWARE VERSIOn
        Creates a new directory for a new piece of software - this also links
        in the new version as the default version, if there aren't any existing
        versions.
    set-current SOFTWARE VERSION
        Links in the given version as the default for the given software, controlling
        which version is added to $PATH (as well as $PKG_CONFIG_PATH and $MANPATH).
        Note that this take effect immediately.
    ls [SOFTWARE]
        Lists out the software installed into USM, and its available versions. If
        SOFTWARE is given, only versions of SOFTWARE are listed.
    path [SOFTWARE] [VERSION]
        Gets the absolute path to the directory storing VERSION of SOFTWARE.
    rm [SOFTWARE] [VERSION]
        Removes VERSIOn of SOFTWARE; if VERSION is the last remaining version, then
        the whole directory under $USM_PATH storing SOFTWARE is removed.
"""

import os
import shutil
import sys

# The directory which USM manages is passed through the environment
try:
    ROOT = os.environ['USM_PATH']
except KeyError:
    print('''
You must set $USM_PATH to the directory where USM keeps its programs. Aborting.
'''.strip())
    sys.exit(1)

# The script used for configuring USM's environment varaibles. Note that
# the word '%THE-USM-PATH%' is replaced when the script is actually copied.

SCRIPT = """# This is the USM initialization file.
# Source it inside your shell's RC file to load USM in your shell automatically,
# or source it from a script which needs USM to run.

export USM_PATH="%THE-USM-PATH%"

# Updates a : separated variable, if a specific entry is not present inside
# it.
update_if_not_in_var() {
    varname=$1
    value=$2
    varvalue="$(eval echo $`eval echo $varname`)"
    echo "$varvalue" | grep "$value" >&/dev/null || eval "$varname=$varvalue:$value"
}

for f in "$USM_PATH"/*; do
    update_if_not_in_var PATH "$f/current/bin"
    update_if_not_in_var PKG_CONFIG_PATH "$f/current/lib/pkgconfig"
    update_if_not_in_var MANPATH "$f/current/man"
    update_if_not_in_var MANPATH "$f/current/share/man"
done
export PATH
export PKG_CONFIG_PATH
export MANPATH
"""

def print_help_and_exit():
    'Prints out the documentation before exiting'
    print(__doc__)
    sys.exit(1)

def assert_software_exists(software, version):
    'Assertss to see if a particular version of a software exists'
    if not os.path.isdir(os.path.join(ROOT, software, version)):
        print('Version', version, 'of', software, 'does not exist')
        sys.exit(1)

def usm_init(*argv):
    'Creates the initial directory structure, and copies the script.'
    print("Creating", ROOT)
    os.mkdir(ROOT)

    COMMANDS['copy-script']()

def usm_copy_script(*argv):
    'Copies over the startup script'
    actual_script = SCRIPT.replace('%THE-USM-PATH%', ROOT)
    script_path = os.path.join(os.environ['HOME'], '.usm-env')

    print("Creating/updating", script_path)
    with open(script_path, 'w') as script_file:
        script_file.write(actual_script)

def usm_add(*argv):
    'Inserts a new version for a piece of software'
    try:
        software, version = argv
    except ValueError:
        print_help_and_exit()

    if version == 'current':
        # This will clash with the symlink for the current version
        print('Cannot use the reserved name "current" as a version.')
        sys.exit(1)

    print('Installing', software, version)

    # Figure out whether or not there are other versions of this software
    is_new = not os.path.isdir(os.path.join(ROOT, software))

    # If it doesn't exist, make the software's directory first...
    if is_new:
        os.mkdir(os.path.join(ROOT, software))

    # ... and then the version's directory
    os.mkdir(os.path.join(ROOT, software, version))

    # Create the 'current' link if there isn't one
    if is_new:
        COMMANDS['set-current'](software, version)

def usm_set_current(*argv):
    'Links a default version in for a sofware'
    try:
        software, version = argv
    except ValueError:
        print_help_and_exit()

    assert_software_exists(software, version) 

    if version == 'current':
        # This will clash with the symlink for the current version
        print('Cannot use the reserved name "current" as a version.')
        sys.exit(1)

    print('Making', version, 'the current for', software)
    current_symlink = os.path.join(ROOT, software, 'current')

    if os.path.exists(current_symlink):
        os.remove(current_symlink)
    os.symlink(os.path.join(ROOT, software, version), current_symlink)

def list_versions(software):
    'Lists all entries for a particular piece of software'
    # The idea here is to be as friendly to parsers as possible, while
    # still being human readable. As long as there aren't any spaces anywhere,
    # the output could be parsed with a simple awk script.
    try:
        versions = os.listdir(os.path.join(ROOT, software))
        versions.remove('current')
        return versions
    except OSError:
        print(software, 'not found')
        return []

def is_current(software, version):
    'Checks to see if a particular version of a software is the current version'
    given_version = os.path.join(ROOT, software, version)
    current_version = os.path.realpath(os.path.join(ROOT, software, 'current'))
    return given_version == current_version

def print_versions(software, versions):
    'Prints out all the versions of a software'
    print(software)
    for version in versions:
        if is_current(software, version):
            print('*', version)
        else:
            print('-', version)

def usm_ls(*argv):
    'Lists all versions of either all, or a particular, software'
    # Mimic the behavior of actual ls, which will show either all files (with no
    # arguments) or specific files (with arguments)
    if argv:
        softwares = argv
    else:
        softwares = os.listdir(ROOT)

    for software in softwares:
        versions = list_versions(software)
        if versions:
            print_versions(software, versions)

def usm_path(*argv):
    'Prints out the path to a particular version of a software'
    try:
        software, version = argv
    except ValueError:
        print_help_and_exit()

    print(os.path.join(ROOT, software, version))

def usm_rm(*argv):
    'Uninstalls a particular version of a software'
    try:
        software, version = argv
    except ValueError:
        print_help_and_exit()

    assert_software_exists(software, version)
    
    # First, check to see if only one version is left - in that case, remove the
    # software as a whole
    if len(list_versions(software)) == 1:
        print('Removing all versions of', software)
        shutil.rmtree(os.path.join(ROOT, software))
        return

    # If another version _can_ be linked, ensure that it _is_ (i.e. the given version
    # isn't current)
    if is_current(software, version):
        print('Cannot remove the current version - please change the current version')
        print('of {software} before trying to delete {software} {version}'.format(
                    software=software, version=version))
        sys.exit(1)

    # Remove the given version, assuming now that it isn't current and that other
    # versions are still there
    print('Removing', software, version)
    shutil.rmtree(os.path.join(ROOT, software, version))
        
COMMANDS = {
    'init': usm_init,
    'copy-script': usm_copy_script,
    'add': usm_add,
    'set-current': usm_set_current,
    'ls': usm_ls,
    'path': usm_path,
    'rm': usm_rm,
}

if __name__ == '__main__':
    # Skip sys.argv[0], the path to the script
    argv = sys.argv[1:]

    try:
        command = argv.pop(0)
    except IndexError:
        print_help_and_exit()

    if command in COMMANDS:
        COMMANDS[command](*argv)
    else:
        print_help_and_exit()
